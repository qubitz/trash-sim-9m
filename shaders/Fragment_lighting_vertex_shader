#version 330

// Vertex shader
layout (location = 0) in vec4 vPosition;

// output values that will be interpolated per-fragment
out vec3 fN;
out vec3 fE;
out vec3 fL;

//layout (location = 0) in vec3 v_position;
layout (location = 1) in vec2 v_color;
layout (location = 2) in vec3 vNormal;
//uniform sampler2D gSampler;
out vec4 color;
out vec4 color2;

uniform vec4 AmbientProduct, DiffuseProduct, SpecularProduct;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
uniform float Shininess;

uniform vec4 LightPosition;

uniform int controlSwitch;

void main()
{
	if(controlSwitch == 0)
	{
	   fN = vNormal;
	   fE = vPosition.xyz;
	   fL = LightPosition.xyz;

	   if( LightPosition.w != 0.0 )
	   {
	      fL = LightPosition.xyz - vPosition.xyz;
	   }

	   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vPosition;
	   color = vec4(v_color, 0.0, 0.0);
	}
	else
	{

	   // transform vertex position into eye coordinates
	   vec3 pos = (viewMatrix * vPosition).xyz;
	   
	   vec3 L = normalize( LightPosition.xyz - pos );
	   vec3 E = normalize( -pos );
	   vec3 H = normalize( L + E );

	   // Transform vertex normal into eye coordinates
	   vec3 N = normalize(viewMatrix * vec4(vNormal, 0.0) ).xyz;

	   // Compute terms in the illumination equation
	   vec4 ambient = AmbientProduct;

	   float Kd = max( dot(L, N), 0.0 );
	   vec4 diffuse = Kd * DiffuseProduct;
	   float Ks = pow( max(dot(N,H), 0.0), Shininess);
	   vec4 specular = Ks * SpecularProduct;
	   if( dot(L,N) < 0.0 ) specular = vec4(0.0, 0.0, 0.0, 1.0);
	   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vPosition;

	   color = ambient + diffuse + specular;
	   color.a = 1.0;
	   color2 = vec4(v_color, 0.0, 0.0);
	}
}
